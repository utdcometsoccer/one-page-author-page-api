name: Build and deploy Azure Functions and Infrastructure

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  DOTNET_VERSION: '10.0.x'
  # Function App paths
  FUNCTION_APP_PATH: 'function-app'
  IMAGE_API_PATH: 'ImageAPI'
  INK_STAINED_WRETCH_FUNCTIONS_PATH: 'InkStainedWretchFunctions'
  INK_STAINED_WRETCH_STRIPE_PATH: 'InkStainedWretchStripe'
  INK_STAINED_WRETCHES_CONFIG_PATH: 'InkStainedWretchesConfig'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: 'Checkout GitHub Action'
        uses: actions/checkout@v4

      - name: Setup DotNet ${{ env.DOTNET_VERSION }} Environment
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      # =========================================
      # Generate Version Number
      # =========================================

      - name: 'Generate Version Number'
        id: version
        shell: bash
        run: |
          # Version format: MAJOR.MINOR.BUILD
          # MAJOR: Increments yearly (starts at 0)
          # MINOR: Increments monthly (1-12), resets to 1 yearly
          # BUILD: GitHub run number
          
          # Calculate major version based on years since project start (2025)
          BASE_YEAR=2025
          CURRENT_YEAR=$(date +%Y)
          MAJOR_VERSION=$((CURRENT_YEAR - BASE_YEAR))
          
          # Calculate minor version based on current month (1-12)
          CURRENT_MONTH=$(date +%-m)
          MINOR_VERSION=$CURRENT_MONTH
          
          BUILD_NUMBER=${{ github.run_number }}
          
          VERSION="${MAJOR_VERSION}.${MINOR_VERSION}.${BUILD_NUMBER}"
          
          # Get short commit SHA for informational version
          SHORT_SHA=$(git rev-parse --short HEAD)
          
          # Informational version includes build metadata
          INFORMATIONAL_VERSION="${VERSION}+sha.${SHORT_SHA}"
          
          echo "Version: ${VERSION}"
          echo "Informational Version: ${INFORMATIONAL_VERSION}"
          echo "Build Number: ${BUILD_NUMBER}"
          echo "Major Version: ${MAJOR_VERSION} (Year: ${CURRENT_YEAR})"
          echo "Minor Version: ${MINOR_VERSION} (Month: ${CURRENT_MONTH})"
          
          # Export for subsequent steps
          echo "VERSION=${VERSION}" >> $GITHUB_ENV
          echo "INFORMATIONAL_VERSION=${INFORMATIONAL_VERSION}" >> $GITHUB_ENV
          echo "BUILD_NUMBER=${BUILD_NUMBER}" >> $GITHUB_ENV

      # =========================================
      # Run Unit Tests
      # =========================================

      - name: 'Run Unit Tests'
        shell: bash
        run: |
          echo "Running unit tests..."
          dotnet test OnePageAuthorAPI.sln --configuration Release --verbosity normal --logger "console;verbosity=detailed"

      # =========================================
      # Build all Function Apps
      # =========================================

      - name: 'Build and Publish function-app'
        shell: bash
        run: |
          echo "Building function-app..."
          echo "Version: ${{ env.VERSION }}"
          echo "Informational Version: ${{ env.INFORMATIONAL_VERSION }}"
          pushd '${{ env.FUNCTION_APP_PATH }}'
          dotnet build --configuration Release /p:Version=${{ env.VERSION }} /p:InformationalVersion=${{ env.INFORMATIONAL_VERSION }}
          dotnet publish --configuration Release --output ./output /p:Version=${{ env.VERSION }} /p:InformationalVersion=${{ env.INFORMATIONAL_VERSION }}
          popd

      - name: 'Zip function-app Output'
        shell: bash
        run: |
          cd '${{ env.FUNCTION_APP_PATH }}/output'
          zip -r ../functionapp.zip .
          cd ../..

      - name: 'Build and Publish ImageAPI'
        shell: bash
        run: |
          echo "Building ImageAPI..."
          echo "Version: ${{ env.VERSION }}"
          echo "Informational Version: ${{ env.INFORMATIONAL_VERSION }}"
          pushd '${{ env.IMAGE_API_PATH }}'
          dotnet build --configuration Release /p:Version=${{ env.VERSION }} /p:InformationalVersion=${{ env.INFORMATIONAL_VERSION }}
          dotnet publish --configuration Release --output ./output /p:Version=${{ env.VERSION }} /p:InformationalVersion=${{ env.INFORMATIONAL_VERSION }}
          popd

      - name: 'Zip ImageAPI Output'
        shell: bash
        run: |
          cd '${{ env.IMAGE_API_PATH }}/output'
          zip -r ../imageapi.zip .
          cd ../..

      - name: 'Build and Publish InkStainedWretchFunctions'
        shell: bash
        run: |
          echo "Building InkStainedWretchFunctions..."
          echo "Version: ${{ env.VERSION }}"
          echo "Informational Version: ${{ env.INFORMATIONAL_VERSION }}"
          pushd '${{ env.INK_STAINED_WRETCH_FUNCTIONS_PATH }}'
          dotnet build --configuration Release /p:Version=${{ env.VERSION }} /p:InformationalVersion=${{ env.INFORMATIONAL_VERSION }}
          dotnet publish --configuration Release --output ./output /p:Version=${{ env.VERSION }} /p:InformationalVersion=${{ env.INFORMATIONAL_VERSION }}
          popd

      - name: 'Zip InkStainedWretchFunctions Output'
        shell: bash
        run: |
          cd '${{ env.INK_STAINED_WRETCH_FUNCTIONS_PATH }}/output'
          zip -r ../inkstainedwretchfunctions.zip .
          cd ../..

      - name: 'Build and Publish InkStainedWretchStripe'
        shell: bash
        run: |
          echo "Building InkStainedWretchStripe..."
          echo "Version: ${{ env.VERSION }}"
          echo "Informational Version: ${{ env.INFORMATIONAL_VERSION }}"
          pushd '${{ env.INK_STAINED_WRETCH_STRIPE_PATH }}'
          dotnet build --configuration Release /p:Version=${{ env.VERSION }} /p:InformationalVersion=${{ env.INFORMATIONAL_VERSION }}
          dotnet publish --configuration Release --output ./output /p:Version=${{ env.VERSION }} /p:InformationalVersion=${{ env.INFORMATIONAL_VERSION }}
          popd

      - name: 'Zip InkStainedWretchStripe Output'
        shell: bash
        run: |
          cd '${{ env.INK_STAINED_WRETCH_STRIPE_PATH }}/output'
          zip -r ../inkstainedwretchstripe.zip .
          cd ../..

      - name: 'Build and Publish InkStainedWretchesConfig'
        shell: bash
        run: |
          echo "Building InkStainedWretchesConfig..."
          echo "Version: ${{ env.VERSION }}"
          echo "Informational Version: ${{ env.INFORMATIONAL_VERSION }}"
          pushd '${{ env.INK_STAINED_WRETCHES_CONFIG_PATH }}'
          dotnet build --configuration Release /p:Version=${{ env.VERSION }} /p:InformationalVersion=${{ env.INFORMATIONAL_VERSION }}
          dotnet publish --configuration Release --output ./output /p:Version=${{ env.VERSION }} /p:InformationalVersion=${{ env.INFORMATIONAL_VERSION }}
          popd

      - name: 'Zip InkStainedWretchesConfig Output'
        shell: bash
        run: |
          cd '${{ env.INK_STAINED_WRETCHES_CONFIG_PATH }}/output'
          zip -r ../inkstainedwretchesconfig.zip .
          cd ../..

      # =========================================
      # Azure Authentication
      # =========================================

      - name: 'Login to Azure'
        continue-on-error: true
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # =========================================
      # Deploy Cosmos DB Account (Conditional)
      # =========================================

      - name: 'Deploy Cosmos DB Account'
        continue-on-error: true
        shell: bash
        env:
          COSMOSDB_RESOURCE_GROUP: ${{ secrets.COSMOSDB_RESOURCE_GROUP }}
          COSMOSDB_ACCOUNT_NAME: ${{ secrets.COSMOSDB_ACCOUNT_NAME }}
          COSMOSDB_LOCATION: ${{ secrets.COSMOSDB_LOCATION }}
          COSMOSDB_ENABLE_FREE_TIER: ${{ secrets.COSMOSDB_ENABLE_FREE_TIER }}
          COSMOSDB_ENABLE_ZONE_REDUNDANCY: ${{ secrets.COSMOSDB_ENABLE_ZONE_REDUNDANCY }}
        run: |
          # Validate required secrets are available
          if [ -z "$COSMOSDB_RESOURCE_GROUP" ] || [ -z "$COSMOSDB_ACCOUNT_NAME" ] || [ -z "$COSMOSDB_LOCATION" ]; then
            echo "‚ö†Ô∏è Skipping Cosmos DB deployment: Required secrets not configured"
            echo "   Required: COSMOSDB_RESOURCE_GROUP, COSMOSDB_ACCOUNT_NAME, COSMOSDB_LOCATION"
            exit 0
          fi

          echo "‚úì Checking if Cosmos DB Account exists..."

          # Check if resource group exists, create if it doesn't
          if ! az group show --name "$COSMOSDB_RESOURCE_GROUP" &> /dev/null; then
            echo "üì¶ Creating resource group: $COSMOSDB_RESOURCE_GROUP"
            az group create --name "$COSMOSDB_RESOURCE_GROUP" --location "$COSMOSDB_LOCATION"
          else
            echo "‚úì Resource group exists: $COSMOSDB_RESOURCE_GROUP"
          fi

          # Check if Cosmos DB Account exists
          if ! az cosmosdb show --name "$COSMOSDB_ACCOUNT_NAME" --resource-group "$COSMOSDB_RESOURCE_GROUP" &> /dev/null; then
            echo "üì¶ Cosmos DB Account does not exist. Deploying..."

            # Build deployment parameters
            PARAMS="cosmosDbAccountName=$COSMOSDB_ACCOUNT_NAME location=$COSMOSDB_LOCATION"

            # Add optional free tier parameter if configured
            if [ "$COSMOSDB_ENABLE_FREE_TIER" = "true" ]; then
              PARAMS="$PARAMS enableFreeTier=true"
              echo "‚úì Free tier will be enabled"
            else
              PARAMS="$PARAMS enableFreeTier=false"
            fi

            # Add optional zone redundancy parameter if configured
            if [ "$COSMOSDB_ENABLE_ZONE_REDUNDANCY" = "true" ]; then
              PARAMS="$PARAMS enableZoneRedundancy=true"
              echo "‚úì Zone redundancy will be enabled"
            else
              PARAMS="$PARAMS enableZoneRedundancy=false"
              echo "‚ö†Ô∏è Zone redundancy disabled (recommended for development)"
            fi

            # Deploy Cosmos DB Account
            az deployment group create \
              --resource-group "$COSMOSDB_RESOURCE_GROUP" \
              --template-file infra/cosmosdb.bicep \
              --parameters $PARAMS \
              --output none

            echo "‚úì Cosmos DB Account deployed successfully"

            # Note: Connection string and keys are available in deployment outputs
            # but not displayed here for security reasons. They can be retrieved from
            # Azure Portal or using Azure CLI: az cosmosdb keys list
          else
            echo "‚úì Cosmos DB Account already exists. Skipping deployment."
          fi

      # =========================================
      # Deploy Application Insights (Conditional)
      # =========================================

      - name: 'Deploy Application Insights'
        continue-on-error: true
        shell: bash
        env:
          COSMOSDB_RESOURCE_GROUP: ${{ secrets.COSMOSDB_RESOURCE_GROUP }}
          APPINSIGHTS_NAME: ${{ secrets.APPINSIGHTS_NAME }}
          COSMOSDB_LOCATION: ${{ secrets.COSMOSDB_LOCATION }}
        run: |
          # Validate required secrets are available
          if [ -z "$COSMOSDB_RESOURCE_GROUP" ] || [ -z "$APPINSIGHTS_NAME" ] || [ -z "$COSMOSDB_LOCATION" ]; then
            echo "‚ö†Ô∏è Skipping Application Insights deployment: Required secrets not configured"
            echo "   Required: COSMOSDB_RESOURCE_GROUP, APPINSIGHTS_NAME, COSMOSDB_LOCATION"
            exit 0
          fi

          echo "‚úì Checking if Application Insights exists..."

          # Check if resource group exists (should exist from Cosmos DB step)
          if ! az group show --name "$COSMOSDB_RESOURCE_GROUP" &> /dev/null; then
            echo "üì¶ Creating resource group: $COSMOSDB_RESOURCE_GROUP"
            az group create --name "$COSMOSDB_RESOURCE_GROUP" --location "$COSMOSDB_LOCATION"
          else
            echo "‚úì Resource group exists: $COSMOSDB_RESOURCE_GROUP"
          fi

          # Check if Application Insights exists
          if ! az monitor app-insights component show --app "$APPINSIGHTS_NAME" --resource-group "$COSMOSDB_RESOURCE_GROUP" &> /dev/null; then
            echo "üì¶ Application Insights does not exist. Deploying..."

            # Deploy Application Insights
            az deployment group create \
              --resource-group "$COSMOSDB_RESOURCE_GROUP" \
              --template-file infra/applicationinsights.bicep \
              --parameters appInsightsName="$APPINSIGHTS_NAME" \
                          location="$COSMOSDB_LOCATION" \
              --output none

            echo "‚úì Application Insights deployed successfully"

            # Note: Instrumentation key and connection string are available in deployment outputs
            # but not displayed here for security reasons. They can be retrieved from
            # Azure Portal or using Azure CLI: az monitor app-insights component show
          else
            echo "‚úì Application Insights already exists. Skipping deployment."
          fi

      # =========================================
      # Deploy Existing function-app Infrastructure
      # =========================================

      - name: 'Deploy function-app Infrastructure'
        continue-on-error: true
        shell: bash
        env:
          FUNCTION_APP_NAME: ${{ secrets.AZURE_FUNCTIONAPP_NAME }}
          RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
          LOCATION: ${{ secrets.AZURE_LOCATION }}
        run: |
          # Validate required secrets are available
          if [ -z "$FUNCTION_APP_NAME" ] || [ -z "$RESOURCE_GROUP" ] || [ -z "$LOCATION" ]; then
            echo "‚ö†Ô∏è Skipping function-app infrastructure deployment: Required secrets not configured"
            echo "   Required: AZURE_FUNCTIONAPP_NAME, AZURE_RESOURCE_GROUP, AZURE_LOCATION"
            exit 0
          fi

          echo "‚úì Checking if function-app exists..."
          # Check if Function App exists
          if ! az functionapp show --name "$FUNCTION_APP_NAME" --resource-group "$RESOURCE_GROUP" &> /dev/null; then
            echo "üì¶ Function App does not exist. Deploying infrastructure..."
            az deployment group create \
              --resource-group "$RESOURCE_GROUP" \
              --template-file infra/functionapp.bicep \
              --parameters functionAppName="$FUNCTION_APP_NAME" \
                          location="$LOCATION"
            echo "‚úì Infrastructure deployed successfully"
          else
            echo "‚úì Function App already exists. Skipping infrastructure deployment."
          fi

      - name: 'Deploy to function-app'
        continue-on-error: true
        shell: bash
        env:
          FUNCTION_APP_NAME: ${{ secrets.AZURE_FUNCTIONAPP_NAME }}
          RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
        run: |
          # Validate required secrets are available
          if [ -z "$FUNCTION_APP_NAME" ] || [ -z "$RESOURCE_GROUP" ]; then
            echo "‚ö†Ô∏è Skipping function-app deployment: Required secrets not configured"
            echo "   Required: AZURE_FUNCTIONAPP_NAME, AZURE_RESOURCE_GROUP"
            exit 0
          fi

          echo "üöÄ Deploying function-app..."
          az functionapp deployment source config-zip \
            --name "$FUNCTION_APP_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            --src '${{ env.FUNCTION_APP_PATH }}/functionapp.zip'
          echo "‚úì function-app deployed successfully"

      # =========================================
      # Register Azure Communication Services Provider (if needed)
      # =========================================

      - name: 'Register Microsoft.Communication Resource Provider'
        # Note: continue-on-error allows optional Communication Services deployment
        # to not block other infrastructure deployments. If registration fails,
        # the subsequent deployment step will fail with a clear error message.
        continue-on-error: true
        shell: bash
        env:
          DEPLOY_COMMUNICATION_SERVICES: ${{ secrets.DEPLOY_COMMUNICATION_SERVICES }}
        run: |
          # Only register if Communication Services deployment is enabled
          if [ "$DEPLOY_COMMUNICATION_SERVICES" != "true" ]; then
            echo "‚ö†Ô∏è Skipping Microsoft.Communication provider registration (DEPLOY_COMMUNICATION_SERVICES not set to 'true')"
            exit 0
          fi

          echo "üì¶ Checking Microsoft.Communication resource provider registration..."

          # Check if provider is already registered (capture stderr separately)
          PROVIDER_STATE_OUTPUT=$(az provider show --namespace Microsoft.Communication --query "registrationState" --output tsv 2>&1)
          PROVIDER_CHECK_EXIT=$?

          if [ $PROVIDER_CHECK_EXIT -ne 0 ]; then
            echo "‚ö†Ô∏è Warning: Unable to check provider status. This may be due to:"
            echo "   - Authentication issues"
            echo "   - Insufficient permissions"
            echo "   - Azure CLI not properly configured"
            echo "   Error output: $PROVIDER_STATE_OUTPUT"
            echo "   Attempting to register provider anyway..."
            PROVIDER_STATE="Unknown"
          else
            PROVIDER_STATE="$PROVIDER_STATE_OUTPUT"
          fi

          if [ "$PROVIDER_STATE" = "Registered" ]; then
            echo "‚úì Microsoft.Communication provider is already registered"
          else
            echo "üìù Registering Microsoft.Communication provider (current state: $PROVIDER_STATE)..."
            if ! REGISTER_OUTPUT=$(az provider register --namespace Microsoft.Communication --wait 2>&1); then
              echo "‚ùå ERROR: Failed to register Microsoft.Communication provider"
              echo "   Error output: $REGISTER_OUTPUT"
              echo "   This is required for Azure Communication Services deployment"
              echo "   Please ensure you have sufficient permissions (Contributor or Owner role)"
              echo "   Continuing anyway - deployment may fail with clear error message"
              exit 0
            fi

            # Verify registration (capture stderr separately)
            PROVIDER_STATE_OUTPUT=$(az provider show --namespace Microsoft.Communication --query "registrationState" --output tsv 2>&1)
            PROVIDER_CHECK_EXIT=$?

            if [ $PROVIDER_CHECK_EXIT -ne 0 ]; then
              echo "‚ö†Ô∏è Warning: Unable to verify provider registration status"
              echo "   Error output: $PROVIDER_STATE_OUTPUT"
              echo "   Deployment will proceed, but may fail if registration is incomplete"
            elif [ "$PROVIDER_STATE_OUTPUT" = "Registered" ]; then
              echo "‚úì Microsoft.Communication provider registered successfully"
            else
              echo "‚ö†Ô∏è Provider registration state: $PROVIDER_STATE_OUTPUT (may still be registering)"
              echo "   Deployment will proceed, but may fail if registration is not complete"
            fi
          fi

      # =========================================
      # Deploy Ink Stained Wretches Infrastructure
      # =========================================

      - name: 'Deploy Ink Stained Wretches Infrastructure'
        continue-on-error: true
        shell: bash
        env:
          # Required deployment configuration
          ISW_RESOURCE_GROUP: ${{ secrets.ISW_RESOURCE_GROUP }}
          ISW_LOCATION: ${{ secrets.ISW_LOCATION }}
          ISW_BASE_NAME: ${{ secrets.ISW_BASE_NAME }}
          ISW_DNS_ZONE_NAME: ${{ secrets.ISW_DNS_ZONE_NAME }}
          DEPLOY_COMMUNICATION_SERVICES: ${{ secrets.DEPLOY_COMMUNICATION_SERVICES }}
          
          # Core secrets (required for basic functionality)
          COSMOSDB_CONNECTION_STRING: ${{ secrets.COSMOSDB_CONNECTION_STRING }}
          COSMOSDB_ENDPOINT_URI: ${{ secrets.COSMOSDB_ENDPOINT_URI }}
          COSMOSDB_PRIMARY_KEY: ${{ secrets.COSMOSDB_PRIMARY_KEY }}
          COSMOSDB_DATABASE_ID: ${{ secrets.COSMOSDB_DATABASE_ID }}
          
          # ImageAPI specific
          AZURE_STORAGE_CONNECTION_STRING: ${{ secrets.AZURE_STORAGE_CONNECTION_STRING }}
          
          # Stripe configuration
          STRIPE_API_KEY: ${{ secrets.STRIPE_API_KEY }}
          STRIPE_WEBHOOK_SECRET: ${{ secrets.STRIPE_WEBHOOK_SECRET }}
          
          # Azure AD Authentication (optional)
          AAD_TENANT_ID: ${{ secrets.AAD_TENANT_ID }}
          AAD_AUDIENCE: ${{ secrets.AAD_AUDIENCE }}
          AAD_CLIENT_ID: ${{ secrets.AAD_CLIENT_ID }}
          AAD_AUTHORITY: ${{ secrets.AAD_AUTHORITY }}
          AAD_VALID_ISSUERS: ${{ secrets.AAD_VALID_ISSUERS }}
          
          # Azure Infrastructure (optional - for domain management)
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_DNS_RESOURCE_GROUP: ${{ secrets.AZURE_DNS_RESOURCE_GROUP }}
          
          # Google Domains Integration (optional)
          GOOGLE_CLOUD_PROJECT_ID: ${{ secrets.GOOGLE_CLOUD_PROJECT_ID }}
          GOOGLE_DOMAINS_LOCATION: ${{ secrets.GOOGLE_DOMAINS_LOCATION }}
          
          # Amazon Product Advertising API (optional)
          AMAZON_PRODUCT_ACCESS_KEY: ${{ secrets.AMAZON_PRODUCT_ACCESS_KEY }}
          AMAZON_PRODUCT_SECRET_KEY: ${{ secrets.AMAZON_PRODUCT_SECRET_KEY }}
          AMAZON_PRODUCT_PARTNER_TAG: ${{ secrets.AMAZON_PRODUCT_PARTNER_TAG }}
          AMAZON_PRODUCT_REGION: ${{ secrets.AMAZON_PRODUCT_REGION }}
          AMAZON_PRODUCT_MARKETPLACE: ${{ secrets.AMAZON_PRODUCT_MARKETPLACE }}
          
          # Penguin Random House API (optional)
          PENGUIN_RANDOM_HOUSE_API_KEY: ${{ secrets.PENGUIN_RANDOM_HOUSE_API_KEY }}
          PENGUIN_RANDOM_HOUSE_API_DOMAIN: ${{ secrets.PENGUIN_RANDOM_HOUSE_API_DOMAIN }}
        run: |
          # Validate required secrets are available
          if [ -z "$ISW_RESOURCE_GROUP" ] || [ -z "$ISW_LOCATION" ] || [ -z "$ISW_BASE_NAME" ]; then
            echo "‚ö†Ô∏è Skipping Ink Stained Wretches infrastructure deployment: Required secrets not configured"
            echo "   Required: ISW_RESOURCE_GROUP, ISW_LOCATION, ISW_BASE_NAME"
            exit 0
          fi

          echo "üì¶ Deploying Ink Stained Wretches Infrastructure..."

          # Check if resource group exists, create if it doesn't
          if ! az group show --name "$ISW_RESOURCE_GROUP" &> /dev/null; then
            echo "Creating resource group: $ISW_RESOURCE_GROUP"
            az group create --name "$ISW_RESOURCE_GROUP" --location "$ISW_LOCATION"
          else
            echo "‚úì Resource group exists: $ISW_RESOURCE_GROUP"
          fi

          # Build deployment parameters
          PARAMS="baseName=$ISW_BASE_NAME location=$ISW_LOCATION"

          # Add optional parameters if configured
          if [ -n "$ISW_DNS_ZONE_NAME" ]; then
            PARAMS="$PARAMS deployDnsZone=true dnsZoneName=$ISW_DNS_ZONE_NAME"
            echo "‚úì DNS Zone will be deployed: $ISW_DNS_ZONE_NAME"
          else
            PARAMS="$PARAMS deployDnsZone=false"
            echo "‚ö†Ô∏è DNS Zone deployment skipped (ISW_DNS_ZONE_NAME not set)"
          fi

          # Add Communication Services deployment parameter
          if [ "$DEPLOY_COMMUNICATION_SERVICES" = "true" ]; then
            PARAMS="$PARAMS deployCommunicationServices=true"
            echo "‚úì Azure Communication Services will be deployed for email notifications"
          else
            PARAMS="$PARAMS deployCommunicationServices=false"
            echo "‚ö†Ô∏è Communication Services deployment skipped (DEPLOY_COMMUNICATION_SERVICES not set to 'true')"
          fi
          
          # Build conditional secure parameters
          SECURE_PARAMS=""
          
          # Add Cosmos DB parameters conditionally
          [ -n "$COSMOSDB_CONNECTION_STRING" ] && SECURE_PARAMS="$SECURE_PARAMS cosmosDbConnectionString='$COSMOSDB_CONNECTION_STRING'"
          [ -n "$COSMOSDB_ENDPOINT_URI" ] && PARAMS="$PARAMS cosmosDbEndpointUri='$COSMOSDB_ENDPOINT_URI'"
          [ -n "$COSMOSDB_PRIMARY_KEY" ] && SECURE_PARAMS="$SECURE_PARAMS cosmosDbPrimaryKey='$COSMOSDB_PRIMARY_KEY'"
          [ -n "$COSMOSDB_DATABASE_ID" ] && PARAMS="$PARAMS cosmosDbDatabaseId='$COSMOSDB_DATABASE_ID'"
          
          # Add ImageAPI storage parameter conditionally
          [ -n "$AZURE_STORAGE_CONNECTION_STRING" ] && SECURE_PARAMS="$SECURE_PARAMS azureStorageConnectionString='$AZURE_STORAGE_CONNECTION_STRING'"
          
          # Add Stripe parameters conditionally
          [ -n "$STRIPE_API_KEY" ] && SECURE_PARAMS="$SECURE_PARAMS stripeApiKey='$STRIPE_API_KEY'"
          [ -n "$STRIPE_WEBHOOK_SECRET" ] && SECURE_PARAMS="$SECURE_PARAMS stripeWebhookSecret='$STRIPE_WEBHOOK_SECRET'"
          
          # Add Azure AD parameters conditionally
          [ -n "$AAD_TENANT_ID" ] && PARAMS="$PARAMS aadTenantId='$AAD_TENANT_ID'"
          [ -n "$AAD_AUDIENCE" ] && PARAMS="$PARAMS aadAudience='$AAD_AUDIENCE'"
          [ -n "$AAD_CLIENT_ID" ] && PARAMS="$PARAMS aadClientId='$AAD_CLIENT_ID'"
          [ -n "$AAD_AUTHORITY" ] && PARAMS="$PARAMS aadAuthority='$AAD_AUTHORITY'"
          [ -n "$AAD_VALID_ISSUERS" ] && PARAMS="$PARAMS aadValidIssuers='$AAD_VALID_ISSUERS'"
          
          # Add Azure Infrastructure parameters conditionally
          [ -n "$AZURE_SUBSCRIPTION_ID" ] && PARAMS="$PARAMS azureSubscriptionId='$AZURE_SUBSCRIPTION_ID'"
          [ -n "$AZURE_DNS_RESOURCE_GROUP" ] && PARAMS="$PARAMS azureDnsResourceGroup='$AZURE_DNS_RESOURCE_GROUP'"
          
          # Add Google Domains parameters conditionally
          [ -n "$GOOGLE_CLOUD_PROJECT_ID" ] && PARAMS="$PARAMS googleCloudProjectId='$GOOGLE_CLOUD_PROJECT_ID'"
          [ -n "$GOOGLE_DOMAINS_LOCATION" ] && PARAMS="$PARAMS googleDomainsLocation='$GOOGLE_DOMAINS_LOCATION'"
          
          # Add Amazon API parameters conditionally
          [ -n "$AMAZON_PRODUCT_ACCESS_KEY" ] && SECURE_PARAMS="$SECURE_PARAMS amazonProductAccessKey='$AMAZON_PRODUCT_ACCESS_KEY'"
          [ -n "$AMAZON_PRODUCT_SECRET_KEY" ] && SECURE_PARAMS="$SECURE_PARAMS amazonProductSecretKey='$AMAZON_PRODUCT_SECRET_KEY'"
          [ -n "$AMAZON_PRODUCT_PARTNER_TAG" ] && PARAMS="$PARAMS amazonProductPartnerTag='$AMAZON_PRODUCT_PARTNER_TAG'"
          [ -n "$AMAZON_PRODUCT_REGION" ] && PARAMS="$PARAMS amazonProductRegion='$AMAZON_PRODUCT_REGION'"
          [ -n "$AMAZON_PRODUCT_MARKETPLACE" ] && PARAMS="$PARAMS amazonProductMarketplace='$AMAZON_PRODUCT_MARKETPLACE'"
          
          # Add Penguin Random House parameters conditionally
          [ -n "$PENGUIN_RANDOM_HOUSE_API_KEY" ] && SECURE_PARAMS="$SECURE_PARAMS penguinRandomHouseApiKey='$PENGUIN_RANDOM_HOUSE_API_KEY'"
          [ -n "$PENGUIN_RANDOM_HOUSE_API_DOMAIN" ] && PARAMS="$PARAMS penguinRandomHouseApiDomain='$PENGUIN_RANDOM_HOUSE_API_DOMAIN'"

          # Deploy infrastructure
          echo "üöÄ Starting infrastructure deployment..."
          echo "Parameters: $PARAMS"
          echo "Secure parameters: [REDACTED]"
          
          # Note: We intentionally don't quote $PARAMS and $SECURE_PARAMS here
          # because they contain multiple space-separated parameter assignments
          # that need to be passed as separate arguments to az deployment
          az deployment group create \
            --resource-group "$ISW_RESOURCE_GROUP" \
            --template-file infra/inkstainedwretches.bicep \
            --parameters $PARAMS $SECURE_PARAMS \
            --output json > deployment-output.json

          echo "‚úì Infrastructure deployment completed"

          # Extract and display outputs
          echo "üìã Deployment outputs:"
          cat deployment-output.json | jq '.properties.outputs'

      # =========================================
      # Deploy ImageAPI Function App
      # =========================================

      - name: 'Deploy ImageAPI Function App'
        continue-on-error: true
        shell: bash
        env:
          ISW_RESOURCE_GROUP: ${{ secrets.ISW_RESOURCE_GROUP }}
          ISW_BASE_NAME: ${{ secrets.ISW_BASE_NAME }}
          DEPLOY_IMAGE_API: ${{ secrets.DEPLOY_IMAGE_API }}
        run: |
          # Skip if ImageAPI deployment is not enabled
          if [ "$DEPLOY_IMAGE_API" != "true" ] || [ -z "$ISW_RESOURCE_GROUP" ] || [ -z "$ISW_BASE_NAME" ]; then
            echo "‚ö†Ô∏è Skipping ImageAPI deployment"
            echo "   DEPLOY_IMAGE_API=$DEPLOY_IMAGE_API"
            echo "   ISW_RESOURCE_GROUP=$ISW_RESOURCE_GROUP"
            echo "   ISW_BASE_NAME=$ISW_BASE_NAME"
            exit 0
          fi

          FUNCTION_APP_NAME="${ISW_BASE_NAME}-imageapi"
          echo "üöÄ Deploying ImageAPI to: $FUNCTION_APP_NAME"

          az functionapp deployment source config-zip \
            --name "$FUNCTION_APP_NAME" \
            --resource-group "$ISW_RESOURCE_GROUP" \
            --src '${{ env.IMAGE_API_PATH }}/imageapi.zip'

          echo "‚úì ImageAPI deployed successfully"

      # =========================================
      # Deploy InkStainedWretchFunctions Function App
      # =========================================

      - name: 'Deploy InkStainedWretchFunctions Function App'
        continue-on-error: true
        shell: bash
        env:
          ISW_RESOURCE_GROUP: ${{ secrets.ISW_RESOURCE_GROUP }}
          ISW_BASE_NAME: ${{ secrets.ISW_BASE_NAME }}
          DEPLOY_ISW_FUNCTIONS: ${{ secrets.DEPLOY_ISW_FUNCTIONS }}
        run: |
          # Skip if InkStainedWretchFunctions deployment is not enabled
          if [ "$DEPLOY_ISW_FUNCTIONS" != "true" ] || [ -z "$ISW_RESOURCE_GROUP" ] || [ -z "$ISW_BASE_NAME" ]; then
            echo "‚ö†Ô∏è Skipping InkStainedWretchFunctions deployment"
            echo "   DEPLOY_ISW_FUNCTIONS=$DEPLOY_ISW_FUNCTIONS"
            echo "   ISW_RESOURCE_GROUP=$ISW_RESOURCE_GROUP"
            echo "   ISW_BASE_NAME=$ISW_BASE_NAME"
            exit 0
          fi

          FUNCTION_APP_NAME="${ISW_BASE_NAME}-functions"
          echo "üöÄ Deploying InkStainedWretchFunctions to: $FUNCTION_APP_NAME"

          az functionapp deployment source config-zip \
            --name "$FUNCTION_APP_NAME" \
            --resource-group "$ISW_RESOURCE_GROUP" \
            --src '${{ env.INK_STAINED_WRETCH_FUNCTIONS_PATH }}/inkstainedwretchfunctions.zip'

          echo "‚úì InkStainedWretchFunctions deployed successfully"

      # =========================================
      # Deploy InkStainedWretchStripe Function App
      # =========================================

      - name: 'Deploy InkStainedWretchStripe Function App'
        continue-on-error: true
        shell: bash
        env:
          ISW_RESOURCE_GROUP: ${{ secrets.ISW_RESOURCE_GROUP }}
          ISW_BASE_NAME: ${{ secrets.ISW_BASE_NAME }}
          DEPLOY_ISW_STRIPE: ${{ secrets.DEPLOY_ISW_STRIPE }}
        run: |
          # Skip if InkStainedWretchStripe deployment is not enabled
          if [ "$DEPLOY_ISW_STRIPE" != "true" ] || [ -z "$ISW_RESOURCE_GROUP" ] || [ -z "$ISW_BASE_NAME" ]; then
            echo "‚ö†Ô∏è Skipping InkStainedWretchStripe deployment"
            echo "   DEPLOY_ISW_STRIPE=$DEPLOY_ISW_STRIPE"
            echo "   ISW_RESOURCE_GROUP=$ISW_RESOURCE_GROUP"
            echo "   ISW_BASE_NAME=$ISW_BASE_NAME"
            exit 0
          fi

          FUNCTION_APP_NAME="${ISW_BASE_NAME}-stripe"
          echo "üöÄ Deploying InkStainedWretchStripe to: $FUNCTION_APP_NAME"

          az functionapp deployment source config-zip \
            --name "$FUNCTION_APP_NAME" \
            --resource-group "$ISW_RESOURCE_GROUP" \
            --src '${{ env.INK_STAINED_WRETCH_STRIPE_PATH }}/inkstainedwretchstripe.zip'

          echo "‚úì InkStainedWretchStripe deployed successfully"

      # =========================================
      # Deploy InkStainedWretchesConfig Function App
      # =========================================

      - name: 'Deploy InkStainedWretchesConfig Function App'
        continue-on-error: true
        shell: bash
        env:
          ISW_RESOURCE_GROUP: ${{ secrets.ISW_RESOURCE_GROUP }}
          ISW_BASE_NAME: ${{ secrets.ISW_BASE_NAME }}
          DEPLOY_ISW_CONFIG: ${{ secrets.DEPLOY_ISW_CONFIG }}
        run: |
          # Skip if InkStainedWretchesConfig deployment is not enabled
          if [ "$DEPLOY_ISW_CONFIG" != "true" ] || [ -z "$ISW_RESOURCE_GROUP" ] || [ -z "$ISW_BASE_NAME" ]; then
            echo "‚ö†Ô∏è Skipping InkStainedWretchesConfig deployment"
            echo "   DEPLOY_ISW_CONFIG=$DEPLOY_ISW_CONFIG"
            echo "   ISW_RESOURCE_GROUP=$ISW_RESOURCE_GROUP"
            echo "   ISW_BASE_NAME=$ISW_BASE_NAME"
            exit 0
          fi

          FUNCTION_APP_NAME="${ISW_BASE_NAME}-config"
          echo "üöÄ Deploying InkStainedWretchesConfig to: $FUNCTION_APP_NAME"

          az functionapp deployment source config-zip \
            --name "$FUNCTION_APP_NAME" \
            --resource-group "$ISW_RESOURCE_GROUP" \
            --src '${{ env.INK_STAINED_WRETCHES_CONFIG_PATH }}/inkstainedwretchesconfig.zip'

          echo "‚úì InkStainedWretchesConfig deployed successfully"
